When integrating changes from a feature branch into your main branch via a pull request, you have two primary options: merging and rebasing. Merging creates a merge commit on the main branch, preserving the entire history of both branches. This approach is safe and straightforward, clearly showing when and how the feature branch was integrated. However, it can lead to a more complex and potentially cluttered commit history, especially with frequent integrations.

Rebasing, on the other hand, rewrites the commit history of the feature branch to appear as if it branched off the latest commit on the main branch. This results in a cleaner, linear history, making it easier to follow the project's evolution. For example, imagine your feature branch `feature/new-feature` diverged from `main` several commits ago. Rebasing `feature/new-feature` onto `main` would replay your feature branch's commits on top of the current `main`, effectively making your feature branch's commits appear as if they were made directly after the latest `main` commit. This is achieved using the command `git rebase main`.

Choosing between merging and rebasing depends on your team's preferences and project needs. If preserving the exact history is crucial, merging is the preferred choice. If a clean, linear history is prioritized, rebasing can be a powerful tool, but it requires careful consideration and should be used with caution, especially when working on shared branches.