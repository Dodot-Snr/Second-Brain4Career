Once a pull request has been reviewed and approved, the final step is merging it into the target branch (typically `main` or `develop`). Merging integrates the changes from the feature branch into the main codebase. GitHub offers several merge strategies, each with its own advantages and disadvantages. The most common are: Merge commit, Squash merge, and Rebase merge. Understanding these strategies is crucial for maintaining a clean and understandable project history.

A **Merge commit** creates a new commit on the target branch that represents the merge, preserving the entire history of the feature branch. This is the default and simplest option. A **Squash merge** combines all commits from the feature branch into a single commit on the target branch, resulting in a cleaner history but losing individual commit details. A **Rebase merge** rewrites the feature branch's history as if it branched off the target branch at the time of the merge, creating a linear history.

For example, imagine a feature branch `feature/new-button` with three commits: "Add button component", "Implement button functionality", and "Fix button styling". Using a merge commit would add a fourth "Merge branch 'feature/new-button'" commit to `main`. A squash merge would create a single commit on `main` like "Add new button feature". A rebase merge would rewrite the `feature/new-button` branch as if it branched from the latest `main` and then fast-forward `main` to include those commits. Choosing the right strategy depends on the project's needs and desired history.