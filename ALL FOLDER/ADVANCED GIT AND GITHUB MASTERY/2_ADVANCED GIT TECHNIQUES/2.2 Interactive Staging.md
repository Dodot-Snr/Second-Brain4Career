Interactive staging, achieved using `git add -i` or `git add --patch`, allows you to selectively stage parts of a file. This is incredibly useful when you've made multiple unrelated changes to a single file and want to commit them separately. Instead of staging the entire file, you can review each change (or "hunk") and decide whether to stage it or not. This gives you fine-grained control over what goes into each commit, leading to cleaner and more logical commit histories.

The interactive staging process presents you with a series of diffs, allowing you to choose to stage, skip, split, or even edit each change. This is particularly helpful when refactoring code or fixing multiple bugs in the same file. For example, imagine you've modified a function to both fix a bug and add a new feature. Using interactive staging, you can stage the bug fix separately, creating a focused commit message like "Fix: Correctly handle edge case in calculate_total function" and then stage the new feature in a separate commit with a message like "Feat: Add support for discount codes in calculate_total function".

Here's a basic example: You've modified `my_script.py` and run `git add -i`. Git will then present you with a series of options. If you choose to patch a file, Git will show you each "hunk" of changes and ask if you want to stage it. You can then type `y` to stage, `n` to skip, `s` to split the hunk into smaller hunks, `e` to manually edit the hunk, and so on. This level of control ensures that your commits are atomic and represent logical units of change.

- [[2.2.1 Git add -p (patch mode)]]
- [[2.2.2 Staging specific changes]]
- [[2.2.3 Reviewing changes before staging]]