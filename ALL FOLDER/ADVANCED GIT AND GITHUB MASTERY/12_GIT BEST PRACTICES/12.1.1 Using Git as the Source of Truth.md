In GitOps, Git isn't just a version control system; it's the single source of truth for your entire system's desired state. This means that all configuration, infrastructure definitions, application code, and policies are stored and versioned within Git repositories. Any changes to the system must be reflected as changes to the Git repository. This approach provides a clear audit trail, enables easy rollback, and promotes collaboration through pull requests and code reviews.

By treating Git as the source of truth, you gain several advantages. For example, imagine you're deploying a new version of your application. Instead of manually configuring servers or running complex deployment scripts, you simply update the application's deployment manifest in Git. A GitOps operator, like Argo CD or Flux, automatically detects the change and reconciles the actual state of the system to match the desired state defined in Git. Similarly, if you need to scale your infrastructure, you modify the infrastructure-as-code definitions in Git, and the GitOps operator provisions the necessary resources.

Another key example is managing Kubernetes deployments. Your Kubernetes manifests (YAML files) are stored in Git. When you want to update the number of replicas for a service, you modify the `replicas` field in the manifest within Git. The GitOps operator then automatically applies this change to your Kubernetes cluster, ensuring that the actual number of replicas matches what's defined in Git. This declarative approach simplifies management and reduces the risk of configuration drift.