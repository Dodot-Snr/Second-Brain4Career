Once a pull request has been reviewed and approved, the final step is merging it into the target branch (typically `main` or `develop`). Merging integrates the changes from the feature branch into the main codebase. GitHub offers several merge strategies, each with its own advantages and disadvantages. The most common are: Merge commit, Squash merge, and Rebase and merge. Understanding these strategies is crucial for maintaining a clean and understandable Git history.

The "Merge commit" strategy creates a new merge commit on the target branch, preserving the entire history of the feature branch. This is the default and simplest option. The "Squash merge" strategy combines all commits from the feature branch into a single commit on the target branch, resulting in a cleaner history but losing individual commit details. The "Rebase and merge" strategy rewrites the feature branch's history to appear as if it branched directly from the latest commit on the target branch, creating a linear history.

For example, if you have a feature branch `feature/new-feature` with 3 commits and you merge it into `main` using the "Merge commit" strategy, a new merge commit will be created on `main` pointing to the last commit of `feature/new-feature`. If you use "Squash merge", all 3 commits from `feature/new-feature` will be squashed into a single commit on `main`. If you use "Rebase and merge", the commits from `feature/new-feature` will be replayed on top of the latest `main` and then merged, creating a linear history. Choosing the right strategy depends on the project's needs and the desired level of detail in the Git history.